<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <script>
      const log = console.log;
      const clear = console.clear;
    </script>
    <script src="../utils.js"></script>
  </head>
  <body>
    <div>
      <h1>Range</h1>
      <ul>
        <li>숫자를받고 그만큼의 숫자를 반환하는 함수</li>
      </ul>
      <script>
        // log(range(5));
        const add = (a, b) => a + b;
        // log(reduce(add, range(4)));
      </script>
    </div>

    <div>
      <h1>느긋한 L.range</h1>
      <ul>
        <li>generator를 이용한다</li>
        <li>
          log(reduce(add, llist)): L.range는 코드 평가가 reduce를 실행하면
          이뤄진다
        </li>
      </ul>
      <script>
        let llist = L.range(5);
        // log("Here", llist);
        // log(reduce(add, llist));
      </script>
    </div>

    <script>
      function test(name, time, f) {
        console.time(name);
        while (time--) f();
        console.timeEnd(name);
      }

      // test("range", 10, () => reduce(add, range(1000000)));
      // test("L.range", 10, () => reduce(add, L.range(1000000)));
    </script>

    <div>
      <h1>take</h1>
      <ul>
        <li>
          인자를두개 받고, limit과 이터러블, limit 갯수까지만 반환하는 함수
        </li>
      </ul>
      <script>
        log(take(5, L.range(100)));
        log(take(5, L.range(Infinity)));

        clear();

        go(range(10000), take(5), log);

        go(L.range(10000), take(5), log);
      </script>
    </div>

    <div>
      <h1>이터러블 중심 프로그래밍에서의 지연 평가(Lazy Evaluation)</h1>
      <ul>
        <li>제때 계산법</li>
        <li>느긋한 계산법</li>
        <li>제너레이터/이터레이터프로토콜을 기반으로 구현</li>
      </ul>
      <script></script>
    </div>

    <div>
      <h1>L.map</h1>
      <ul>
        <li></li>
      </ul>
      <script>
        var it = L.map((a) => a + 10, [1, 2, 3]);
        log([...it]);
      </script>
    </div>

    <div>
      <h1>L.filter</h1>
      <ul>
        <li></li>
      </ul>
      <script>
        var it = L.filter((a) => a % 2, [1, 2, 3, 4, 5]);
        log([...it]);
      </script>
    </div>

    <div>
      <h1>range, map, filter, take, reduce 중첩 사용</h1>
      <ul>
        <li></li>
      </ul>
      <script>
        go(
          range(10),
          map((n) => n + 10),
          filter((n) => n % 2),
          take(2),
          log
        );
      </script>
    </div>

    <div>
      <h1>L.range, L.map, L.filter, L.take, L.reduce 중첩 사용</h1>
      <ul>
        <li></li>
      </ul>
      <script>
        go(
          L.range(10),
          L.map((n) => n + 10),
          L.filter((n) => n % 2),
          take(2),
          log
        );
      </script>
    </div>

    <div>
      <h1>map, filter 계열 함수들이 가지는 결합 법칙</h1>
      <ul>
        <li>사용하는 데이터가 무엇이든지</li>
        <li>사용하는 보조 함수가 순수 함수라면 무엇이든지</li>
        <li>아래와 같이 결합한다면 둘다 결과가 같다</li>
        <li>
          [[maapping, mapping], [filtering, filtering], [mapping, mapping]]
          <br />
          = <br />
          [[mapping, filtering, mapping], [mapping, filtering, mapping]]
        </li>
      </ul>
      <script></script>
    </div>
  </body>
</html>
